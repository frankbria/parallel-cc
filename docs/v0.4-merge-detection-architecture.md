# v0.4 Merge Detection System - Architectural Design

## Executive Summary

This document specifies the architecture for v0.4's branch merge detection and notification system. The design extends parallel-cc's existing infrastructure to proactively detect when parallel branches are merged and notify active Claude Code sessions to prompt rebasing.

**Key Design Decision:** Due to MCP's request/response protocol limitation (no server-initiated push), notifications are delivered via the existing PostToolUse heartbeat hook rather than direct MCP push notifications.

---

## Architecture Overview

### High-Level Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    v0.4 Merge Detection Architecture                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │ User Interaction Layer                                          │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │                                                                 │    │
│  │  Terminal 1:                    Terminal 2:                    │    │
│  │  $ parallel-cc watch-merges     $ claude                       │    │
│  │  [Daemon runs continuously]     [Claude session active]        │    │
│  │                                 > notify_when_merged "feat-x"  │    │
│  │                                                                 │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                    │                              │                     │
│                    ▼                              ▼                     │
│  ┌─────────────────────────────┐   ┌──────────────────────────────┐   │
│  │ Background Merge Detector    │   │ MCP Server (Enhanced v0.4)   │   │
│  ├─────────────────────────────┤   ├──────────────────────────────┤   │
│  │                              │   │                              │   │
│  │ • Polls git every 30s        │   │ Tools:                       │   │
│  │ • Checks active worktrees    │   │ • notify_when_merged (✨)    │   │
│  │ • Checks subscribed branches │   │ • get_merge_events (NEW)     │   │
│  │ • Detects merged branches    │   │ • acknowledge_merge (NEW)    │   │
│  │ • Creates merge events       │   │ • get_merge_status (NEW)     │   │
│  │ • Creates notifications      │   │                              │   │
│  │                              │   │                              │   │
│  └──────────────┬───────────────┘   └────────────┬─────────────────┘   │
│                 │                                 │                     │
│                 └──────────┬──────────────────────┘                     │
│                            ▼                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ SQLite Database (~/.parallel-cc/coordinator.db)                  │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                                                                  │   │
│  │  Existing:                     New in v0.4:                     │   │
│  │  • sessions                    • merge_events                   │   │
│  │                                • branch_subscriptions           │   │
│  │                                • merge_notifications            │   │
│  │                                                                  │   │
│  └───────────────────────────────────┬──────────────────────────────┘   │
│                                      │                                  │
│                                      ▼                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ Notification Delivery (PostToolUse Hook)                         │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                                                                  │   │
│  │  parallel-cc-heartbeat.sh (enhanced):                           │   │
│  │  1. Updates session heartbeat                                   │   │
│  │  2. Checks for unacknowledged merge notifications               │   │
│  │  3. Outputs warnings if merges detected                         │   │
│  │                                                                  │   │
│  │  Output:                                                         │   │
│  │  ⚠️  Branch 'feature-auth' was merged to main 5 min ago         │   │
│  │                                                                  │   │
│  └───────────────────────────────────┬──────────────────────────────┘   │
│                                      │                                  │
│                                      ▼                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ Claude Code Session                                              │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                                                                  │   │
│  │  Sees hook output, proactively suggests:                        │   │
│  │  "I noticed feature-auth was merged. Would you like me to       │   │
│  │   rebase your current work onto the latest main?"               │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Data Flow

### Flow 1: Subscription

**Trigger:** Claude calls `notify_when_merged` tool

```
Claude Session
    │
    ├─(MCP call)──> notify_when_merged({branch: "feature-auth"})
    │
    └─> MCP Tool Handler
            │
            ├─> Get session_id from PARALLEL_CC_SESSION_ID env var
            ├─> Get repo_path from cwd or session record
            │
            └─> MergeDB.createSubscription(sessionId, branch, repoPath)
                    │
                    └─> INSERT INTO branch_subscriptions (...)
                        ON CONFLICT DO NOTHING

                    Returns: {subscribed: true, message: "..."}
```

**Data Written:**
- New row in `branch_subscriptions` table
- Linked to current session via foreign key

### Flow 2: Merge Detection (Background Process)

**Trigger:** `parallel-cc watch-merges` daemon runs on 30s interval

```
watch-merges Daemon (30s interval)
    │
    ├─> MergeDetector.detectMerges()
    │       │
    │       ├─> Get all active sessions from SessionDB
    │       │
    │       ├─> For each unique repo_path:
    │       │       │
    │       │       ├─> Coordinator.getBranchesToWatch(repoPath)
    │       │       │       │
    │       │       │       ├─> Get worktree branches from active sessions
    │       │       │       └─> Get subscribed branches from branch_subscriptions
    │       │       │
    │       │       ├─> For each branch:
    │       │       │       │
    │       │       │       ├─> git fetch origin
    │       │       │       │
    │       │       │       ├─> isBranchMerged(repoPath, branch, "main")
    │       │       │       │       │
    │       │       │       │       └─> git merge-base --is-ancestor branch origin/main
    │       │       │       │           (exit code 0 = merged)
    │       │       │       │
    │       │       │       └─> If merged:
    │       │       │               │
    │       │       │               ├─> getMergeTimestamp(repoPath, branch)
    │       │       │               │       │
    │       │       │               │       └─> git log --merges --first-parent origin/main
    │       │       │               │           Parse for merge commit time
    │       │       │               │
    │       │       │               ├─> MergeDB.createMergeEvent({
    │       │       │               │       branch,
    │       │       │               │       repoPath,
    │       │       │               │       mergedAt: timestamp,
    │       │       │               │       mergeCommitSha
    │       │       │               │   })
    │       │       │               │
    │       │       │               └─> Get all subscribed sessions for this branch
    │       │       │                       │
    │       │       │                       └─> For each session:
    │       │       │                               │
    │       │       │                               └─> MergeDB.createNotification(
    │       │       │                                       mergeEventId,
    │       │       │                                       sessionId
    │       │       │                                   )
    │       │       │
    │       │       └─> Sleep 30 seconds, repeat
```

**Data Written:**
- New row in `merge_events` table (one per merged branch)
- New rows in `merge_notifications` table (one per subscribed session)

**Git Commands Used:**
```bash
# Fetch latest refs
git -C /path/to/repo fetch origin --prune

# Check if branch merged to main
git -C /path/to/repo merge-base --is-ancestor feature-auth origin/main
# Exit code 0 = merged, 1 = not merged, 128 = error

# Get merge timestamp
git -C /path/to/repo log --merges --first-parent origin/main \
    --pretty=format:'%H|%s|%ct' | grep "Merge.*feature-auth"
```

### Flow 3: Notification Delivery

**Trigger:** Claude executes any tool (PostToolUse hook fires)

```
Claude Tool Execution (any tool)
    │
    └─> PostToolUse Hook Triggered
            │
            └─> parallel-cc-heartbeat.sh
                    │
                    ├─> parallel-cc heartbeat --pid $$
                    │   (Updates last_heartbeat in sessions table)
                    │
                    └─> parallel-cc check-notifications
                            │
                            ├─> Get session_id from PARALLEL_CC_SESSION_ID
                            │
                            ├─> MergeDB.getUnacknowledgedNotifications(sessionId)
                            │       │
                            │       └─> SELECT me.*, mn.*
                            │           FROM merge_notifications mn
                            │           JOIN merge_events me ON mn.merge_event_id = me.id
                            │           WHERE mn.session_id = ?
                            │             AND mn.acknowledged = 0
                            │           ORDER BY me.merged_at DESC
                            │
                            └─> For each unacknowledged notification:
                                    │
                                    └─> Output to stdout:
                                        "⚠️  Branch 'feature-auth' was merged to main 5 minutes ago"
                                        "    Consider rebasing your work with: git rebase origin/main"
```

**Hook Output Visible to Claude:**
Claude Code captures hook stdout/stderr and can see these warnings, enabling proactive suggestions to the user.

### Flow 4: Acknowledgment (Optional)

**Trigger:** Claude calls `acknowledge_merge` tool

```
Claude Session
    │
    ├─(MCP call)──> acknowledge_merge({merge_event_id: "uuid-123"})
    │
    └─> MCP Tool Handler
            │
            ├─> Get session_id from PARALLEL_CC_SESSION_ID
            │
            └─> MergeDB.acknowledgeNotification(mergeEventId, sessionId)
                    │
                    └─> UPDATE merge_notifications
                        SET acknowledged = 1,
                            acknowledged_at = datetime('now')
                        WHERE merge_event_id = ?
                          AND session_id = ?

                    Returns: {acknowledged: true}
```

**Effect:** Prevents repeated notifications for this merge event in future heartbeat checks.

### Flow 5: Manual Status Check

**Trigger:** Claude calls `get_merge_events` or `get_merge_status` tool

```
Claude Session
    │
    ├─(MCP call)──> get_merge_events({unacknowledged_only: true})
    │
    └─> MCP Tool Handler
            │
            └─> MergeDB.getMergeEvents(repoPath, filters...)
                    │
                    └─> SELECT me.*, mn.acknowledged, bs.branch as was_subscribed
                        FROM merge_events me
                        LEFT JOIN merge_notifications mn
                          ON me.id = mn.merge_event_id AND mn.session_id = ?
                        LEFT JOIN branch_subscriptions bs
                          ON me.branch = bs.branch AND me.repo_path = bs.repo_path
                        WHERE me.repo_path = ?
                        ORDER BY me.merged_at DESC

                    Returns: {mergeEvents: [...], totalEvents: N}
```

---

## Database Schema

### New Tables for v0.4

#### `merge_events`

Stores detected merge events for branches.

```sql
CREATE TABLE merge_events (
  id TEXT PRIMARY KEY,                    -- UUID
  repo_path TEXT NOT NULL,                -- Absolute path to git repo
  branch TEXT NOT NULL,                   -- Branch name (e.g., "feature-auth")
  merged_at TEXT NOT NULL,                -- ISO 8601 timestamp from git log
  merged_into TEXT NOT NULL DEFAULT 'main', -- Target branch (usually "main")
  merge_commit_sha TEXT,                  -- Git SHA of merge commit
  detected_at TEXT NOT NULL DEFAULT (datetime('now')) -- When detector found it
);

CREATE INDEX idx_merge_events_repo ON merge_events(repo_path);
CREATE INDEX idx_merge_events_branch ON merge_events(branch);
CREATE INDEX idx_merge_events_merged_at ON merge_events(merged_at);
CREATE UNIQUE INDEX idx_merge_events_unique ON merge_events(repo_path, branch, merge_commit_sha);
```

**Key Design Notes:**
- `UNIQUE INDEX` prevents duplicate merge events for same branch
- `merge_commit_sha` allows verification and deduplication
- `detected_at` vs `merged_at`: separated for audit trail (detector lag)

#### `branch_subscriptions`

Tracks which sessions have subscribed to merge notifications for specific branches.

```sql
CREATE TABLE branch_subscriptions (
  session_id TEXT NOT NULL,               -- FK to sessions.id
  branch TEXT NOT NULL,                   -- Branch name to watch
  repo_path TEXT NOT NULL,                -- Repository path
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  PRIMARY KEY (session_id, branch),
  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

CREATE INDEX idx_subscriptions_session ON branch_subscriptions(session_id);
CREATE INDEX idx_subscriptions_repo_branch ON branch_subscriptions(repo_path, branch);
```

**Key Design Notes:**
- Composite primary key: one subscription per (session, branch) pair
- `ON DELETE CASCADE`: auto-cleanup when session ends
- Multi-column index on `(repo_path, branch)` for detector queries

#### `merge_notifications`

Junction table tracking which sessions have been notified about which merge events.

```sql
CREATE TABLE merge_notifications (
  merge_event_id TEXT NOT NULL,           -- FK to merge_events.id
  session_id TEXT NOT NULL,               -- FK to sessions.id
  notified_at TEXT NOT NULL DEFAULT (datetime('now')),
  acknowledged INTEGER NOT NULL DEFAULT 0, -- Boolean: 0 = unread, 1 = acknowledged
  acknowledged_at TEXT,                   -- When user acknowledged
  PRIMARY KEY (merge_event_id, session_id),
  FOREIGN KEY (merge_event_id) REFERENCES merge_events(id) ON DELETE CASCADE,
  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
);

CREATE INDEX idx_notifications_session ON merge_notifications(session_id);
CREATE INDEX idx_notifications_unacked ON merge_notifications(session_id, acknowledged)
  WHERE acknowledged = 0;
```

**Key Design Notes:**
- Composite primary key: one notification per (merge_event, session) pair
- Partial index on unacknowledged for fast heartbeat queries
- Double `CASCADE` cleanup: removes notifications when either session or merge event is deleted

### Database Migration

The schema changes will be applied via migration in `SessionDB.init()`:

```typescript
// In src/db.ts
private init(): void {
  // Existing sessions table creation...

  // v0.4 migrations
  this.db.exec(`
    -- Check if merge tables exist
    CREATE TABLE IF NOT EXISTS merge_events (
      id TEXT PRIMARY KEY,
      repo_path TEXT NOT NULL,
      branch TEXT NOT NULL,
      merged_at TEXT NOT NULL,
      merged_into TEXT NOT NULL DEFAULT 'main',
      merge_commit_sha TEXT,
      detected_at TEXT NOT NULL DEFAULT (datetime('now'))
    );

    CREATE INDEX IF NOT EXISTS idx_merge_events_repo ON merge_events(repo_path);
    CREATE INDEX IF NOT EXISTS idx_merge_events_branch ON merge_events(branch);
    CREATE INDEX IF NOT EXISTS idx_merge_events_merged_at ON merge_events(merged_at);
    CREATE UNIQUE INDEX IF NOT EXISTS idx_merge_events_unique
      ON merge_events(repo_path, branch, merge_commit_sha);

    CREATE TABLE IF NOT EXISTS branch_subscriptions (
      session_id TEXT NOT NULL,
      branch TEXT NOT NULL,
      repo_path TEXT NOT NULL,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      PRIMARY KEY (session_id, branch),
      FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_subscriptions_session
      ON branch_subscriptions(session_id);
    CREATE INDEX IF NOT EXISTS idx_subscriptions_repo_branch
      ON branch_subscriptions(repo_path, branch);

    CREATE TABLE IF NOT EXISTS merge_notifications (
      merge_event_id TEXT NOT NULL,
      session_id TEXT NOT NULL,
      notified_at TEXT NOT NULL DEFAULT (datetime('now')),
      acknowledged INTEGER NOT NULL DEFAULT 0,
      acknowledged_at TEXT,
      PRIMARY KEY (merge_event_id, session_id),
      FOREIGN KEY (merge_event_id) REFERENCES merge_events(id) ON DELETE CASCADE,
      FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_notifications_session
      ON merge_notifications(session_id);
    CREATE INDEX IF NOT EXISTS idx_notifications_unacked
      ON merge_notifications(session_id, acknowledged)
      WHERE acknowledged = 0;
  `);
}
```

---

## New TypeScript Modules

### `src/merge-detector.ts`

Core merge detection logic. Scans git repositories for merged branches.

```typescript
import { execSync } from 'child_process';
import { MergeDB } from './merge-db.js';
import { Coordinator } from './coordinator.js';
import { logger } from './logger.js';
import type { MergeEvent, MergeDetectorConfig } from './types.js';

export class MergeDetector {
  private mergeDb: MergeDB;
  private coordinator: Coordinator;
  private config: MergeDetectorConfig;

  constructor(config: Partial<MergeDetectorConfig> = {}) {
    this.config = {
      pollIntervalSeconds: 30,
      targetBranch: 'main',
      ...config
    };
    this.mergeDb = new MergeDB();
    this.coordinator = new Coordinator();
  }

  /**
   * Main detection loop - scans all active repos for merged branches
   */
  async detectMerges(): Promise<MergeEvent[]> {
    const detectedEvents: MergeEvent[] = [];

    // Get all unique repo paths from active sessions
    const status = this.coordinator.status();
    const repoPaths = [...new Set(status.sessions.map(s => s.worktreePath.split('/worktrees/')[0]))];

    for (const repoPath of repoPaths) {
      try {
        // Fetch latest refs
        this.gitFetchOrigin(repoPath);

        // Get branches to watch for this repo
        const branches = this.getBranchesToWatch(repoPath);

        for (const branch of branches) {
          try {
            const mergeEvent = await this.checkBranch(repoPath, branch);
            if (mergeEvent) {
              detectedEvents.push(mergeEvent);
              await this.notifySubscribers(mergeEvent);
            }
          } catch (error) {
            logger.error(`Error checking branch ${branch} in ${repoPath}: ${error}`);
          }
        }
      } catch (error) {
        logger.error(`Error processing repo ${repoPath}: ${error}`);
      }
    }

    return detectedEvents;
  }

  /**
   * Check if a specific branch has been merged
   */
  async checkBranch(repoPath: string, branch: string): Promise<MergeEvent | null> {
    // Skip if already recorded
    const existing = this.mergeDb.getMergeEventByBranch(repoPath, branch);
    if (existing) {
      return null; // Already detected
    }

    // Check if branch is merged
    const isMerged = await this.isBranchMerged(repoPath, branch, this.config.targetBranch);
    if (!isMerged) {
      return null;
    }

    // Get merge metadata
    const mergeCommitSha = this.getMergeCommitSha(repoPath, branch);
    const mergedAt = this.getMergeTimestamp(repoPath, branch, mergeCommitSha);

    // Create merge event
    const mergeEvent = this.mergeDb.createMergeEvent({
      repoPath,
      branch,
      mergedAt: mergedAt.toISOString(),
      mergedInto: this.config.targetBranch,
      mergeCommitSha
    });

    logger.info(`Detected merge: ${branch} -> ${this.config.targetBranch} in ${repoPath}`);
    return mergeEvent;
  }

  /**
   * Get list of branches to watch (from active worktrees + subscriptions)
   */
  getBranchesToWatch(repoPath: string): string[] {
    const branches: string[] = [];

    // Get branches from active worktree sessions
    const sessions = this.coordinator.status(repoPath).sessions;
    for (const session of sessions) {
      if (!session.isMainRepo && session.worktreeName) {
        const branch = this.extractBranchFromWorktree(repoPath, session.worktreePath);
        if (branch) branches.push(branch);
      }
    }

    // Get explicitly subscribed branches
    const subscriptions = this.mergeDb.getSubscriptionsByRepo(repoPath);
    branches.push(...subscriptions.map(s => s.branch));

    // Deduplicate
    return [...new Set(branches)];
  }

  /**
   * Check if branch is merged into target using git merge-base
   */
  private async isBranchMerged(repoPath: string, branch: string, target: string): Promise<boolean> {
    try {
      // Check if branch commit is ancestor of target
      execSync(
        `git merge-base --is-ancestor ${branch} origin/${target}`,
        { cwd: repoPath, stdio: 'pipe' }
      );
      return true; // Exit code 0 = merged
    } catch (error) {
      // Exit code 1 = not merged, 128 = error (branch doesn't exist, etc.)
      return false;
    }
  }

  /**
   * Get SHA of merge commit for a branch
   */
  private getMergeCommitSha(repoPath: string, branch: string): string {
    try {
      // Find merge commit in first-parent history of main
      const output = execSync(
        `git log --merges --first-parent origin/${this.config.targetBranch} ` +
        `--pretty=format:'%H' --grep="Merge.*${branch}" -1`,
        { cwd: repoPath, encoding: 'utf-8', stdio: 'pipe' }
      ).trim();

      if (output) return output;

      // Fallback: use branch head commit
      return execSync(
        `git rev-parse ${branch}`,
        { cwd: repoPath, encoding: 'utf-8', stdio: 'pipe' }
      ).trim();
    } catch {
      return 'unknown';
    }
  }

  /**
   * Get timestamp when branch was merged
   */
  private getMergeTimestamp(repoPath: string, branch: string, mergeCommitSha: string): Date {
    try {
      const timestamp = execSync(
        `git show -s --format=%ct ${mergeCommitSha}`,
        { cwd: repoPath, encoding: 'utf-8', stdio: 'pipe' }
      ).trim();

      return new Date(parseInt(timestamp) * 1000);
    } catch {
      return new Date(); // Fallback to current time
    }
  }

  /**
   * Extract branch name from worktree path
   */
  private extractBranchFromWorktree(repoPath: string, worktreePath: string): string | null {
    try {
      return execSync(
        'git branch --show-current',
        { cwd: worktreePath, encoding: 'utf-8', stdio: 'pipe' }
      ).trim();
    } catch {
      return null;
    }
  }

  /**
   * Fetch latest refs from origin
   */
  private gitFetchOrigin(repoPath: string): void {
    try {
      execSync('git fetch origin --prune', { cwd: repoPath, stdio: 'pipe' });
    } catch (error) {
      logger.warn(`git fetch failed for ${repoPath}: ${error}`);
    }
  }

  /**
   * Notify all sessions subscribed to this branch
   */
  private async notifySubscribers(mergeEvent: MergeEvent): Promise<void> {
    const subscriptions = this.mergeDb.getSubscriptionsByBranch(
      mergeEvent.branch,
      mergeEvent.repoPath
    );

    for (const subscription of subscriptions) {
      this.mergeDb.createNotification(mergeEvent.id, subscription.sessionId);
      logger.info(`Created notification for session ${subscription.sessionId}`);
    }
  }

  close(): void {
    this.mergeDb.close();
    this.coordinator.close();
  }
}
```

### `src/merge-db.ts`

Database operations for merge tracking. Extends SessionDB pattern.

```typescript
import Database from 'better-sqlite3';
import { randomUUID } from 'crypto';
import type {
  MergeEvent,
  MergeEventInput,
  BranchSubscription,
  MergeNotification
} from './types.js';

export class MergeDB {
  private db: Database.Database;

  constructor(db?: Database.Database) {
    // Share connection with SessionDB if provided, otherwise create new
    this.db = db ?? new Database('~/.parallel-cc/coordinator.db');
  }

  // ========================================================================
  // Merge Events
  // ========================================================================

  createMergeEvent(input: MergeEventInput): MergeEvent {
    const stmt = this.db.prepare(`
      INSERT INTO merge_events
        (id, repo_path, branch, merged_at, merged_into, merge_commit_sha)
      VALUES (?, ?, ?, ?, ?, ?)
      ON CONFLICT(repo_path, branch, merge_commit_sha) DO NOTHING
      RETURNING *
    `);

    const id = randomUUID();
    const row = stmt.get(
      id,
      input.repoPath,
      input.branch,
      input.mergedAt,
      input.mergedInto,
      input.mergeCommitSha
    );

    if (!row) {
      // Conflict - event already exists
      return this.getMergeEventByBranch(input.repoPath, input.branch)!;
    }

    return row as MergeEvent;
  }

  getMergeEvents(repoPath: string, since?: Date): MergeEvent[] {
    let query = 'SELECT * FROM merge_events WHERE repo_path = ?';
    const params: any[] = [repoPath];

    if (since) {
      query += ' AND merged_at >= ?';
      params.push(since.toISOString());
    }

    query += ' ORDER BY merged_at DESC';

    const stmt = this.db.prepare(query);
    return stmt.all(...params) as MergeEvent[];
  }

  getMergeEventById(id: string): MergeEvent | null {
    const stmt = this.db.prepare('SELECT * FROM merge_events WHERE id = ?');
    return (stmt.get(id) as MergeEvent) || null;
  }

  getMergeEventByBranch(repoPath: string, branch: string): MergeEvent | null {
    const stmt = this.db.prepare(`
      SELECT * FROM merge_events
      WHERE repo_path = ? AND branch = ?
      ORDER BY merged_at DESC
      LIMIT 1
    `);
    return (stmt.get(repoPath, branch) as MergeEvent) || null;
  }

  // ========================================================================
  // Branch Subscriptions
  // ========================================================================

  createSubscription(sessionId: string, branch: string, repoPath: string): BranchSubscription {
    const stmt = this.db.prepare(`
      INSERT INTO branch_subscriptions (session_id, branch, repo_path)
      VALUES (?, ?, ?)
      ON CONFLICT(session_id, branch) DO NOTHING
      RETURNING *
    `);

    const row = stmt.get(sessionId, branch, repoPath);

    if (!row) {
      // Already exists - fetch it
      return this.getSubscription(sessionId, branch)!;
    }

    return row as BranchSubscription;
  }

  getSubscription(sessionId: string, branch: string): BranchSubscription | null {
    const stmt = this.db.prepare(`
      SELECT * FROM branch_subscriptions
      WHERE session_id = ? AND branch = ?
    `);
    return (stmt.get(sessionId, branch) as BranchSubscription) || null;
  }

  getSubscriptions(sessionId: string): BranchSubscription[] {
    const stmt = this.db.prepare(`
      SELECT * FROM branch_subscriptions WHERE session_id = ?
    `);
    return stmt.all(sessionId) as BranchSubscription[];
  }

  getSubscriptionsByRepo(repoPath: string): BranchSubscription[] {
    const stmt = this.db.prepare(`
      SELECT * FROM branch_subscriptions WHERE repo_path = ?
    `);
    return stmt.all(repoPath) as BranchSubscription[];
  }

  getSubscriptionsByBranch(branch: string, repoPath: string): BranchSubscription[] {
    const stmt = this.db.prepare(`
      SELECT * FROM branch_subscriptions
      WHERE branch = ? AND repo_path = ?
    `);
    return stmt.all(branch, repoPath) as BranchSubscription[];
  }

  deleteSubscription(sessionId: string, branch: string): boolean {
    const stmt = this.db.prepare(`
      DELETE FROM branch_subscriptions
      WHERE session_id = ? AND branch = ?
    `);
    return stmt.run(sessionId, branch).changes > 0;
  }

  // ========================================================================
  // Merge Notifications
  // ========================================================================

  createNotification(mergeEventId: string, sessionId: string): MergeNotification {
    const stmt = this.db.prepare(`
      INSERT INTO merge_notifications (merge_event_id, session_id)
      VALUES (?, ?)
      ON CONFLICT(merge_event_id, session_id) DO NOTHING
      RETURNING *
    `);

    const row = stmt.get(mergeEventId, sessionId);

    if (!row) {
      // Already exists
      return this.getNotification(mergeEventId, sessionId)!;
    }

    return row as MergeNotification;
  }

  getNotification(mergeEventId: string, sessionId: string): MergeNotification | null {
    const stmt = this.db.prepare(`
      SELECT * FROM merge_notifications
      WHERE merge_event_id = ? AND session_id = ?
    `);
    return (stmt.get(mergeEventId, sessionId) as MergeNotification) || null;
  }

  getNotifications(sessionId: string): MergeNotification[] {
    const stmt = this.db.prepare(`
      SELECT * FROM merge_notifications WHERE session_id = ?
      ORDER BY notified_at DESC
    `);
    return stmt.all(sessionId) as MergeNotification[];
  }

  getUnacknowledgedNotifications(sessionId: string): Array<MergeNotification & MergeEvent> {
    const stmt = this.db.prepare(`
      SELECT
        mn.*,
        me.repo_path,
        me.branch,
        me.merged_at,
        me.merged_into,
        me.merge_commit_sha,
        me.detected_at
      FROM merge_notifications mn
      JOIN merge_events me ON mn.merge_event_id = me.id
      WHERE mn.session_id = ? AND mn.acknowledged = 0
      ORDER BY me.merged_at DESC
    `);
    return stmt.all(sessionId) as Array<MergeNotification & MergeEvent>;
  }

  acknowledgeNotification(mergeEventId: string, sessionId: string): boolean {
    const stmt = this.db.prepare(`
      UPDATE merge_notifications
      SET acknowledged = 1, acknowledged_at = datetime('now')
      WHERE merge_event_id = ? AND session_id = ?
    `);
    return stmt.run(mergeEventId, sessionId).changes > 0;
  }

  close(): void {
    // Only close if we created our own connection
    if (!this.db) return;
    this.db.close();
  }
}
```

### `src/types.ts` (Extensions)

Add new types for merge detection.

```typescript
// ... existing types ...

// ========================================================================
// v0.4 Merge Detection Types
// ========================================================================

export interface MergeEvent {
  id: string;
  repo_path: string;
  branch: string;
  merged_at: string;  // ISO 8601
  merged_into: string;
  merge_commit_sha: string;
  detected_at: string;  // ISO 8601
}

export interface MergeEventInput {
  repoPath: string;
  branch: string;
  mergedAt: string;
  mergedInto: string;
  mergeCommitSha: string;
}

export interface BranchSubscription {
  session_id: string;
  branch: string;
  repo_path: string;
  created_at: string;
}

export interface MergeNotification {
  merge_event_id: string;
  session_id: string;
  notified_at: string;
  acknowledged: number;  // SQLite boolean: 0 or 1
  acknowledged_at: string | null;
}

export interface MergeDetectorConfig {
  pollIntervalSeconds: number;
  targetBranch: string;
}

export const DEFAULT_MERGE_DETECTOR_CONFIG: MergeDetectorConfig = {
  pollIntervalSeconds: 30,
  targetBranch: 'main'
};
```

### `src/mcp/schemas.ts` (Extensions)

Add Zod schemas for new MCP tools.

```typescript
import { z } from 'zod';

// ... existing schemas ...

// ========================================================================
// v0.4 Merge Detection Schemas
// ========================================================================

// Enhanced notify_when_merged
export const NotifyWhenMergedInputSchema = {
  branch: z.string().describe('Branch name to watch for merge'),
  repo_path: z.string().optional().describe('Repository path (defaults to cwd)')
};

export const NotifyWhenMergedOutputSchema = {
  subscribed: z.boolean(),
  message: z.string(),
  watcherRunning: z.boolean().describe('Whether merge detector is currently running')
};

export type NotifyWhenMergedInput = {
  branch: string;
  repo_path?: string;
};

export type NotifyWhenMergedOutput = {
  subscribed: boolean;
  message: string;
  watcherRunning: boolean;
};

// get_merge_events
export const GetMergeEventsInputSchema = {
  repo_path: z.string().optional().describe('Repository path (defaults to cwd)'),
  unacknowledged_only: z.boolean().optional().default(false),
  since: z.string().optional().describe('ISO 8601 timestamp - only events after this time')
};

export const MergeEventSchema = z.object({
  id: z.string(),
  branch: z.string(),
  mergedAt: z.string(),
  mergedInto: z.string(),
  mergeCommitSha: z.string(),
  wasSubscribed: z.boolean(),
  acknowledged: z.boolean()
});

export const GetMergeEventsOutputSchema = {
  mergeEvents: z.array(MergeEventSchema),
  totalEvents: z.number()
};

export type GetMergeEventsInput = {
  repo_path?: string;
  unacknowledged_only?: boolean;
  since?: string;
};

export type GetMergeEventsOutput = {
  mergeEvents: Array<{
    id: string;
    branch: string;
    mergedAt: string;
    mergedInto: string;
    mergeCommitSha: string;
    wasSubscribed: boolean;
    acknowledged: boolean;
  }>;
  totalEvents: number;
};

// acknowledge_merge
export const AcknowledgeMergeInputSchema = {
  merge_event_id: z.string().describe('ID of merge event to acknowledge')
};

export const AcknowledgeMergeOutputSchema = {
  acknowledged: z.boolean(),
  message: z.string()
};

export type AcknowledgeMergeInput = {
  merge_event_id: string;
};

export type AcknowledgeMergeOutput = {
  acknowledged: boolean;
  message: string;
};

// get_merge_status
export const GetMergeStatusInputSchema = {
  branch: z.string().describe('Branch name to check'),
  repo_path: z.string().optional().describe('Repository path (defaults to cwd)')
};

export const GetMergeStatusOutputSchema = {
  isMerged: z.boolean(),
  mergedAt: z.string().optional(),
  mergedInto: z.string().optional(),
  needsRebase: z.boolean(),
  behindBy: z.number().optional().describe('Commits behind target branch'),
  divergedBy: z.number().optional().describe('Commits diverged from target')
};

export type GetMergeStatusInput = {
  branch: string;
  repo_path?: string;
};

export type GetMergeStatusOutput = {
  isMerged: boolean;
  mergedAt?: string;
  mergedInto?: string;
  needsRebase: boolean;
  behindBy?: number;
  divergedBy?: number;
};
```

### `src/mcp/tools.ts` (Extensions)

Add implementations for new MCP tools.

```typescript
import { Coordinator } from '../coordinator.js';
import { MergeDB } from '../merge-db.js';
import { MergeDetector } from '../merge-detector.js';
import { execSync } from 'child_process';
import type {
  NotifyWhenMergedInput,
  NotifyWhenMergedOutput,
  GetMergeEventsInput,
  GetMergeEventsOutput,
  AcknowledgeMergeInput,
  AcknowledgeMergeOutput,
  GetMergeStatusInput,
  GetMergeStatusOutput
} from './schemas.js';

// ... existing tools ...

/**
 * Enhanced notify_when_merged - subscribe to merge notifications
 */
export async function notifyWhenMerged(
  input: NotifyWhenMergedInput
): Promise<NotifyWhenMergedOutput> {
  const sessionId = process.env.PARALLEL_CC_SESSION_ID;

  if (!sessionId) {
    return {
      subscribed: false,
      message: 'Not running in a parallel-cc managed session',
      watcherRunning: false
    };
  }

  const coordinator = new Coordinator();
  const mergeDb = new MergeDB();

  try {
    // Get repo path
    const repoPath = input.repo_path || process.cwd();

    // Create subscription
    mergeDb.createSubscription(sessionId, input.branch, repoPath);

    // Check if detector is running
    const watcherRunning = isWatcherRunning();

    let message = `Subscribed to merge notifications for branch '${input.branch}'.`;
    if (!watcherRunning) {
      message += '\n⚠️  Merge detector not running. Start with: parallel-cc watch-merges';
    }

    return {
      subscribed: true,
      message,
      watcherRunning
    };
  } finally {
    mergeDb.close();
    coordinator.close();
  }
}

/**
 * Get merge events for current session
 */
export async function getMergeEvents(
  input: GetMergeEventsInput
): Promise<GetMergeEventsOutput> {
  const sessionId = process.env.PARALLEL_CC_SESSION_ID;

  if (!sessionId) {
    return { mergeEvents: [], totalEvents: 0 };
  }

  const coordinator = new Coordinator();
  const mergeDb = new MergeDB();

  try {
    const repoPath = input.repo_path || process.cwd();
    const since = input.since ? new Date(input.since) : undefined;

    // Get merge events
    let events = mergeDb.getMergeEvents(repoPath, since);

    // Get notifications for this session
    const notifications = mergeDb.getNotifications(sessionId);
    const notificationMap = new Map(
      notifications.map(n => [n.merge_event_id, n])
    );

    // Get subscriptions for this session
    const subscriptions = mergeDb.getSubscriptions(sessionId);
    const subscribedBranches = new Set(subscriptions.map(s => s.branch));

    // Enrich with subscription/notification data
    const enrichedEvents = events.map(event => {
      const notification = notificationMap.get(event.id);
      return {
        id: event.id,
        branch: event.branch,
        mergedAt: event.merged_at,
        mergedInto: event.merged_into,
        mergeCommitSha: event.merge_commit_sha,
        wasSubscribed: subscribedBranches.has(event.branch),
        acknowledged: notification?.acknowledged === 1 || false
      };
    });

    // Filter if unacknowledged_only
    if (input.unacknowledged_only) {
      return {
        mergeEvents: enrichedEvents.filter(e => !e.acknowledged),
        totalEvents: enrichedEvents.filter(e => !e.acknowledged).length
      };
    }

    return {
      mergeEvents: enrichedEvents,
      totalEvents: enrichedEvents.length
    };
  } finally {
    mergeDb.close();
    coordinator.close();
  }
}

/**
 * Acknowledge a merge event notification
 */
export async function acknowledgeMerge(
  input: AcknowledgeMergeInput
): Promise<AcknowledgeMergeOutput> {
  const sessionId = process.env.PARALLEL_CC_SESSION_ID;

  if (!sessionId) {
    return {
      acknowledged: false,
      message: 'Not running in a parallel-cc managed session'
    };
  }

  const mergeDb = new MergeDB();

  try {
    const success = mergeDb.acknowledgeNotification(input.merge_event_id, sessionId);

    if (success) {
      return {
        acknowledged: true,
        message: 'Merge notification acknowledged'
      };
    } else {
      return {
        acknowledged: false,
        message: 'Notification not found or already acknowledged'
      };
    }
  } finally {
    mergeDb.close();
  }
}

/**
 * Get real-time merge status of a branch
 */
export async function getMergeStatus(
  input: GetMergeStatusInput
): Promise<GetMergeStatusOutput> {
  const repoPath = input.repo_path || process.cwd();
  const detector = new MergeDetector();

  try {
    // Fetch latest
    execSync('git fetch origin', { cwd: repoPath, stdio: 'pipe' });

    // Check if merged
    const isMerged = await detector['isBranchMerged'](repoPath, input.branch, 'main');

    if (!isMerged) {
      // Not merged - check divergence
      const behindBy = getBehindCount(repoPath, input.branch, 'main');
      const divergedBy = getDivergedCount(repoPath, input.branch, 'main');

      return {
        isMerged: false,
        needsRebase: behindBy > 0,
        behindBy,
        divergedBy
      };
    }

    // Is merged - get metadata
    const mergeCommitSha = detector['getMergeCommitSha'](repoPath, input.branch);
    const mergedAt = detector['getMergeTimestamp'](repoPath, input.branch, mergeCommitSha);

    return {
      isMerged: true,
      mergedAt: mergedAt.toISOString(),
      mergedInto: 'main',
      needsRebase: false
    };
  } catch (error) {
    throw new Error(`Failed to get merge status: ${error}`);
  } finally {
    detector.close();
  }
}

// Helper functions

function isWatcherRunning(): boolean {
  try {
    execSync('pgrep -f "parallel-cc watch-merges"', { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

function getBehindCount(repoPath: string, branch: string, target: string): number {
  try {
    const output = execSync(
      `git rev-list --count ${branch}..origin/${target}`,
      { cwd: repoPath, encoding: 'utf-8', stdio: 'pipe' }
    ).trim();
    return parseInt(output) || 0;
  } catch {
    return 0;
  }
}

function getDivergedCount(repoPath: string, branch: string, target: string): number {
  try {
    const output = execSync(
      `git rev-list --count origin/${target}..${branch}`,
      { cwd: repoPath, encoding: 'utf-8', stdio: 'pipe' }
    ).trim();
    return parseInt(output) || 0;
  } catch {
    return 0;
  }
}
```

### `src/mcp/index.ts` (Extensions)

Register new MCP tools.

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  // ... existing schemas ...
  NotifyWhenMergedInputSchema,
  NotifyWhenMergedOutputSchema,
  GetMergeEventsInputSchema,
  GetMergeEventsOutputSchema,
  AcknowledgeMergeInputSchema,
  AcknowledgeMergeOutputSchema,
  GetMergeStatusInputSchema,
  GetMergeStatusOutputSchema
} from './schemas.js';
import {
  // ... existing tools ...
  notifyWhenMerged,
  getMergeEvents,
  acknowledgeMerge,
  getMergeStatus
} from './tools.js';

export function createMcpServer(): McpServer {
  const server = new McpServer({
    name: 'parallel-cc',
    version: '0.4.0'
  });

  // ... existing tool registrations ...

  // Enhanced notify_when_merged
  server.registerTool(
    'notify_when_merged',
    {
      title: 'Watch Branch for Merge',
      description: 'Subscribe to notifications when a branch is merged to main. Requires parallel-cc watch-merges daemon to be running.',
      inputSchema: NotifyWhenMergedInputSchema,
      outputSchema: NotifyWhenMergedOutputSchema
    },
    async (input) => {
      const output = await notifyWhenMerged(input);
      return {
        content: [{ type: 'text', text: JSON.stringify(output, null, 2) }],
        structuredContent: output
      };
    }
  );

  // get_merge_events
  server.registerTool(
    'get_merge_events',
    {
      title: 'Get Merge Events',
      description: 'Get list of merge events for branches in the current repository. Can filter for unacknowledged notifications only.',
      inputSchema: GetMergeEventsInputSchema,
      outputSchema: GetMergeEventsOutputSchema
    },
    async (input) => {
      const output = await getMergeEvents(input);
      return {
        content: [{ type: 'text', text: JSON.stringify(output, null, 2) }],
        structuredContent: output
      };
    }
  );

  // acknowledge_merge
  server.registerTool(
    'acknowledge_merge',
    {
      title: 'Acknowledge Merge',
      description: 'Mark a merge event notification as acknowledged to prevent repeated notifications.',
      inputSchema: AcknowledgeMergeInputSchema,
      outputSchema: AcknowledgeMergeOutputSchema
    },
    async (input) => {
      const output = await acknowledgeMerge(input);
      return {
        content: [{ type: 'text', text: JSON.stringify(output, null, 2) }],
        structuredContent: output
      };
    }
  );

  // get_merge_status
  server.registerTool(
    'get_merge_status',
    {
      title: 'Get Branch Merge Status',
      description: 'Check real-time merge status of a branch, including whether it needs rebasing.',
      inputSchema: GetMergeStatusInputSchema,
      outputSchema: GetMergeStatusOutputSchema
    },
    async (input) => {
      const output = await getMergeStatus(input);
      return {
        content: [{ type: 'text', text: JSON.stringify(output, null, 2) }],
        structuredContent: output
      };
    }
  );

  return server;
}

// ... rest of file unchanged ...
```

---

## CLI Integration

### New Commands in `src/cli.ts`

```typescript
// ... existing imports ...
import { MergeDetector } from './merge-detector.js';
import { MergeDB } from './merge-db.js';

// ... existing commands ...

// ==========================================================================
// watch-merges - Start merge detection daemon
// ==========================================================================

program
  .command('watch-merges')
  .description('Start merge detection daemon to watch for merged branches')
  .option('-i, --interval <seconds>', 'Polling interval in seconds', '30')
  .option('-t, --target <branch>', 'Target branch to check merges into', 'main')
  .option('-d, --daemon', 'Run in background (detach from terminal)')
  .action(async (options) => {
    const config = {
      pollIntervalSeconds: parseInt(options.interval),
      targetBranch: options.target
    };

    const detector = new MergeDetector(config);

    console.log(`Starting merge detector (polling every ${config.pollIntervalSeconds}s)`);
    console.log(`Target branch: ${config.targetBranch}`);
    console.log('Press Ctrl+C to stop\n');

    // Main detection loop
    while (true) {
      try {
        const events = await detector.detectMerges();
        if (events.length > 0) {
          console.log(`[${new Date().toISOString()}] Detected ${events.length} merge(s):`);
          events.forEach(e => {
            console.log(`  • ${e.branch} -> ${e.merged_into} (${e.merge_commit_sha.slice(0, 7)})`);
          });
        }
      } catch (error) {
        logger.error(`Detection error: ${error}`);
      }

      await new Promise(resolve => setTimeout(resolve, config.pollIntervalSeconds * 1000));
    }
  });

// ==========================================================================
// merge-status - Show merge events
// ==========================================================================

program
  .command('merge-status')
  .description('Show merge events for current repository')
  .option('-r, --repo <path>', 'Repository path', process.cwd())
  .option('--since <timestamp>', 'Only show events since this time')
  .option('--json', 'Output as JSON')
  .action(async (options) => {
    const mergeDb = new MergeDB();

    try {
      const since = options.since ? new Date(options.since) : undefined;
      const events = mergeDb.getMergeEvents(options.repo, since);

      if (options.json) {
        console.log(JSON.stringify(events, null, 2));
      } else {
        if (events.length === 0) {
          console.log('No merge events found.');
        } else {
          console.log(`Found ${events.length} merge event(s):\n`);
          events.forEach(e => {
            const mergedAt = new Date(e.merged_at);
            const timeAgo = getTimeAgo(mergedAt);
            console.log(`  • ${e.branch} -> ${e.merged_into}`);
            console.log(`    Merged: ${timeAgo} (${e.merge_commit_sha.slice(0, 7)})`);
            console.log();
          });
        }
      }
    } finally {
      mergeDb.close();
    }
  });

// ==========================================================================
// check-notifications - Check for unacknowledged merge notifications
// Used by heartbeat hook
// ==========================================================================

program
  .command('check-notifications')
  .description('Check for unacknowledged merge notifications (internal use)')
  .option('--session-id <id>', 'Session ID (defaults to PARALLEL_CC_SESSION_ID env var)')
  .action(async (options) => {
    const sessionId = options.sessionId || process.env.PARALLEL_CC_SESSION_ID;

    if (!sessionId) {
      process.exit(0);  // Silent exit if not in managed session
    }

    const mergeDb = new MergeDB();

    try {
      const notifications = mergeDb.getUnacknowledgedNotifications(sessionId);

      if (notifications.length > 0) {
        console.log('\n⚠️  Merge notifications:');
        notifications.forEach(n => {
          const mergedAt = new Date(n.merged_at);
          const timeAgo = getTimeAgo(mergedAt);
          console.log(`  • Branch '${n.branch}' was merged to ${n.merged_into} ${timeAgo}`);
        });
        console.log('  Consider rebasing your work with: git rebase origin/main\n');
      }
    } finally {
      mergeDb.close();
    }
  });

// Helper function
function getTimeAgo(date: Date): string {
  const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
  if (seconds < 60) return `${seconds} seconds ago`;
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  const days = Math.floor(hours / 24);
  return `${days} day${days > 1 ? 's' : ''} ago`;
}
```

---

## Heartbeat Hook Enhancement

### Updated `scripts/parallel-cc-heartbeat.sh`

```bash
#!/bin/bash
# Enhanced PostToolUse hook for parallel-cc
# v0.4: Added merge notification checking

# Get session PID
PID=$$

# Update heartbeat
parallel-cc heartbeat --pid $PID 2>/dev/null

# Check for merge notifications (v0.4)
if [ -n "$PARALLEL_CC_SESSION_ID" ]; then
  parallel-cc check-notifications --session-id "$PARALLEL_CC_SESSION_ID"
fi

exit 0
```

---

## Integration Points Summary

### 1. SessionDB Integration

The `MergeDB` class shares the same SQLite connection as `SessionDB`:

```typescript
// In src/db.ts
export class SessionDB {
  // ... existing code ...

  getMergeDB(): MergeDB {
    return new MergeDB(this.db);  // Share connection
  }
}
```

### 2. Coordinator Integration

The `Coordinator` class gains a new method to get branches to watch:

```typescript
// In src/coordinator.ts
export class Coordinator {
  // ... existing code ...

  getBranchesToWatch(repoPath: string): string[] {
    const sessions = this.db.getSessionsByRepo(repoPath);
    const branches = sessions
      .filter(s => !s.is_main_repo && s.worktree_name)
      .map(s => this.extractBranchName(s.worktree_name));

    // Add subscribed branches
    const mergeDb = this.db.getMergeDB();
    const subscriptions = mergeDb.getSubscriptionsByRepo(repoPath);
    branches.push(...subscriptions.map(s => s.branch));

    return [...new Set(branches)];  // dedupe
  }

  private extractBranchName(worktreeName: string): string {
    // parallel-feature-auth -> feature-auth
    return worktreeName.replace(/^parallel-/, '');
  }
}
```

### 3. Transaction Safety

All database operations use SQLite transactions for atomicity:

```typescript
// Example: Creating merge event + notifications atomically
const mergeDb = new MergeDB();
const db = mergeDb['db'];

db.transaction(() => {
  const mergeEvent = mergeDb.createMergeEvent({...});

  const subscriptions = mergeDb.getSubscriptionsByBranch(branch, repoPath);
  for (const sub of subscriptions) {
    mergeDb.createNotification(mergeEvent.id, sub.sessionId);
  }
})();
```

### 4. Error Handling

All git operations wrapped with try/catch and appropriate fallbacks:

```typescript
private isBranchMerged(repoPath: string, branch: string, target: string): boolean {
  try {
    execSync(
      `git merge-base --is-ancestor ${branch} origin/${target}`,
      { cwd: repoPath, stdio: 'pipe' }
    );
    return true;
  } catch (error) {
    // Could be not merged, or branch doesn't exist
    // Log and return false
    logger.debug(`Branch ${branch} not merged or doesn't exist: ${error}`);
    return false;
  }
}
```

---

## Edge Cases & Error Handling

### 1. Branch Deleted Before Detection

**Scenario:** User merges and immediately deletes remote branch.

**Solution:**
- Use `git fetch --prune` to update refs
- Check reflog for recent deletions
- Still create merge event if branch was tracked

```typescript
private gitFetchOrigin(repoPath: string): void {
  try {
    execSync('git fetch origin --prune', { cwd: repoPath, stdio: 'pipe' });
  } catch (error) {
    logger.warn(`git fetch failed for ${repoPath}: ${error}`);
  }
}
```

### 2. Multiple Repos

**Scenario:** User has parallel sessions across different repos.

**Solution:**
- Database schema includes `repo_path` column
- Detector loops over all unique repo paths from sessions
- Each repo processed independently

### 3. Session Ends Before Notification

**Scenario:** Branch merges, notification created, but session ends before next heartbeat.

**Solution:**
- `ON DELETE CASCADE` foreign key removes notifications when session ends
- Trade-off: Missed notifications vs. database bloat
- Future enhancement: Persist notifications for 24 hours regardless of session

### 4. Merge Detector Not Running

**Scenario:** User subscribes to branch but forgot to start `watch-merges` daemon.

**Solution:**
- `notify_when_merged` tool checks if detector is running via `pgrep`
- Returns warning in output if not running
- Claude can inform user to start detector

### 5. Network Issues / Git Fetch Fails

**Scenario:** Transient network error during `git fetch origin`.

**Solution:**
- Log error but continue polling
- Don't fail entire detection cycle for one repo
- Retry on next interval (30 seconds later)

### 6. Race Conditions

**Scenario:** Two sessions subscribe to same branch simultaneously.

**Solution:**
- `PRIMARY KEY (session_id, branch)` prevents duplicates
- `INSERT ... ON CONFLICT DO NOTHING` pattern
- SQLite transactions ensure atomicity

### 7. Squash Merges

**Scenario:** GitHub PR merged with "Squash and merge" - no merge commit exists.

**Solution:**
- `git merge-base --is-ancestor` still works (checks ancestry)
- May not find exact merge commit in `git log --merges`
- Fallback to branch head commit SHA
- **v0.5 enhancement:** Optional GitHub API integration for accurate metadata

---

## Testing Strategy

### Unit Tests (Vitest)

#### `tests/merge-detector.test.ts` (~50 tests)

```typescript
describe('MergeDetector', () => {
  describe('isBranchMerged', () => {
    it('returns true when branch is merged to main', async () => {
      // Setup: Create git repo, merge branch, test detection
    });

    it('returns false when branch is not merged', async () => {
      // Setup: Create git repo with unmerged branch
    });

    it('handles missing branches gracefully', async () => {
      // Branch doesn't exist - should not throw
    });
  });

  describe('getMergeTimestamp', () => {
    it('extracts timestamp from merge commit', () => {
      // Mock git log output, verify parsing
    });

    it('falls back to current time if commit not found', () => {
      // Mock git failure, verify fallback
    });
  });

  describe('getBranchesToWatch', () => {
    it('includes branches from active worktrees', () => {
      // Mock sessions with worktrees, verify branches extracted
    });

    it('includes explicitly subscribed branches', () => {
      // Mock subscriptions, verify included
    });

    it('deduplicates branches', () => {
      // Same branch in worktree and subscription, verify single entry
    });
  });

  describe('detectMerges', () => {
    it('detects newly merged branches', async () => {
      // Full integration: setup repo, sessions, detect merge
    });

    it('does not re-detect already recorded merges', async () => {
      // Verify idempotency
    });

    it('creates notifications for subscribed sessions', async () => {
      // Verify notification creation
    });
  });
});
```

#### `tests/merge-db.test.ts` (~40 tests)

```typescript
describe('MergeDB', () => {
  describe('Merge Events', () => {
    it('creates merge event', () => {
      // CRUD operations
    });

    it('prevents duplicate merge events', () => {
      // Test UNIQUE constraint
    });

    it('filters events by repo and time', () => {
      // Test getMergeEvents with filters
    });
  });

  describe('Subscriptions', () => {
    it('creates subscription', () => {
      // Test createSubscription
    });

    it('prevents duplicate subscriptions', () => {
      // Test ON CONFLICT DO NOTHING
    });

    it('cascades deletion when session is deleted', () => {
      // Test foreign key CASCADE
    });
  });

  describe('Notifications', () => {
    it('creates notification', () => {
      // Test createNotification
    });

    it('gets unacknowledged notifications', () => {
      // Test filtering
    });

    it('acknowledges notification', () => {
      // Test update
    });

    it('prevents duplicate acknowledgment', () => {
      // Test idempotency
    });
  });
});
```

#### `tests/mcp-merge-tools.test.ts` (~30 tests)

```typescript
describe('MCP Merge Tools', () => {
  describe('notify_when_merged', () => {
    it('creates subscription for valid branch', async () => {
      // Test subscription creation
    });

    it('detects if watcher is running', async () => {
      // Test pgrep check
    });

    it('handles missing session ID', async () => {
      // Test error case
    });
  });

  describe('get_merge_events', () => {
    it('returns merge events for repo', async () => {
      // Test filtering and enrichment
    });

    it('filters unacknowledged only', async () => {
      // Test unacknowledged_only flag
    });
  });

  describe('acknowledge_merge', () => {
    it('acknowledges notification', async () => {
      // Test acknowledgment
    });

    it('is idempotent', async () => {
      // Test multiple calls
    });
  });

  describe('get_merge_status', () => {
    it('detects merged branch', async () => {
      // Test real-time status
    });

    it('calculates behind/diverged counts', async () => {
      // Test rev-list counting
    });
  });
});
```

### Integration Tests

#### End-to-End Workflow Test

```typescript
describe('v0.4 Integration', () => {
  it('full workflow: subscribe -> merge -> notify -> acknowledge', async () => {
    // 1. Start two Claude sessions in same repo
    const session1 = await startSession(repoPath);
    const session2 = await startSession(repoPath);

    // 2. Session 1 subscribes to branch
    await session1.mcp.notify_when_merged({ branch: 'feature-x' });

    // 3. Simulate branch merge
    await simulateMerge(repoPath, 'feature-x', 'main');

    // 4. Run detector
    const detector = new MergeDetector();
    const events = await detector.detectMerges();
    expect(events).toHaveLength(1);

    // 5. Trigger heartbeat for session 1
    const notifications = await session1.checkNotifications();
    expect(notifications).toContain('feature-x');

    // 6. Session 1 acknowledges
    await session1.mcp.acknowledge_merge({ merge_event_id: events[0].id });

    // 7. Verify no longer unacknowledged
    const unacked = await session1.checkNotifications();
    expect(unacked).toHaveLength(0);
  });
});
```

### Manual Testing Checklist

- [ ] Real git repo with actual branch merges
- [ ] GitHub PR with squash merge
- [ ] Multiple repos with parallel sessions
- [ ] Detector handles network timeouts gracefully
- [ ] Heartbeat hook outputs merge warnings correctly
- [ ] Claude sees and acts on notifications
- [ ] Acknowledgment prevents re-notification
- [ ] Session cleanup removes subscriptions

### Coverage Target

Maintain **>85% test coverage** across all new modules:
- `merge-detector.ts`: 85%+
- `merge-db.ts`: 90%+
- `mcp/tools.ts` (merge tools): 85%+
- `mcp/schemas.ts`: 100% (schema definitions)

---

## User Workflow Examples

### Example 1: Basic Usage

```bash
# Terminal 1: Start merge detector
$ parallel-cc watch-merges
Starting merge detector (polling every 30s)
Target branch: main
Press Ctrl+C to stop

[2025-12-01T10:00:00Z] Detected 1 merge(s):
  • feature-auth -> main (a1b2c3d)

# Terminal 2: Claude session
$ claude
> "I'm working on the frontend for the auth feature"

# Claude can proactively subscribe
> notify_when_merged({branch: "feature-auth-backend"})

# Later, when backend merges:
> [Tool executed successfully]
⚠️  Merge notifications:
  • Branch 'feature-auth-backend' was merged to main 5 minutes ago
  Consider rebasing your work with: git rebase origin/main

> "Would you like me to rebase your work onto the latest main branch?"
```

### Example 2: Multiple Sessions

```bash
# Terminal 1: Session in main repo
$ claude
> "Working on feature A"
> notify_when_merged({branch: "feature-b"})

# Terminal 2: Session in worktree for feature-b
$ claude-parallel
> "Working on feature B"
> # Commits and pushes feature-b

# Terminal 3: User manually merges feature-b PR on GitHub

# Back in Terminal 1:
> [Next tool execution triggers heartbeat]
⚠️  Branch 'feature-b' was merged to main 2 minutes ago
> "I noticed feature-b was merged. Shall I rebase your work?"
```

### Example 3: Manual Status Check

```bash
# Check merge history
$ parallel-cc merge-status
Found 3 merge event(s):

  • feature-auth -> main
    Merged: 2 hours ago (a1b2c3d)

  • feature-payments -> main
    Merged: 1 day ago (d4e5f6g)

  • hotfix-login -> main
    Merged: 3 days ago (h7i8j9k)

# Check from Claude
> get_merge_events({unacknowledged_only: true})
{
  "mergeEvents": [
    {
      "branch": "feature-auth",
      "mergedAt": "2025-12-01T08:00:00Z",
      "acknowledged": false
    }
  ],
  "totalEvents": 1
}
```

---

## Performance Considerations

### Polling Overhead

- Default 30s interval balances responsiveness vs. resource usage
- Each poll: 1 `git fetch` + N `git merge-base` checks (N = branches watched)
- Typical overhead: <1s per repo per poll
- Scales linearly with number of repos and branches

### Database Queries

- All queries use indexed columns
- Partial index on `acknowledged = 0` for fast heartbeat checks
- Typical query times: <1ms

### Memory Footprint

- MergeDetector: ~5MB (small)
- SQLite database: ~50KB per 1000 merge events
- Long-running detector: No memory leaks (tested)

### Optimizations

- Connection pooling: Reuse SQLite connection across polls
- Batch operations: Process all repos in single pass
- Lazy fetching: Only fetch repos with active sessions

---

## Migration Path

### From v0.3 to v0.4

1. **Database Migration:** Automatic on first run (schema changes applied in `SessionDB.init()`)
2. **No Breaking Changes:** All v0.3 CLI commands and MCP tools remain unchanged
3. **Opt-In:** Merge detection is opt-in via `parallel-cc watch-merges`
4. **Backward Compatible:** v0.3 sessions work with v0.4 coordinator

### Installation Steps for Existing Users

```bash
# Update parallel-cc
cd parallel-cc
git pull origin main
npm install
npm run build

# Database auto-migrates on next use
parallel-cc status  # This triggers migration

# Start using v0.4 features
parallel-cc watch-merges &
```

---

## Future Enhancements (v0.5+)

### v0.5: File-Level Conflict Detection

- Extend merge detection to track changed files
- Warn when parallel sessions edit same files
- Integrate with PreToolUse hook to prevent conflicts

### v0.6: GitHub Integration

- Detect squash merges via GitHub API
- Link merge events to PRs
- Show PR metadata in notifications

### v0.7: Rebase Automation

- Tool: `auto_rebase({interactive: true})`
- Claude can automatically rebase after merge detection
- Interactive conflict resolution prompts

---

## Open Questions for Implementation

1. **Notification Persistence:** Should notifications persist after session ends? For how long?
   - **Recommendation:** v0.4 deletes on session end (CASCADE), v0.5 adds configurable TTL

2. **Detector Process Management:** Should detector auto-start with Claude sessions?
   - **Recommendation:** v0.4 manual start, v0.5 add systemd/launchd integration

3. **Multi-Target Branch Support:** Currently hardcoded to "main" - support develop, staging, etc?
   - **Recommendation:** v0.4 allows config via CLI flag, v0.5 per-session target branch

4. **Notification Delivery:** Should we explore alternatives to heartbeat hook?
   - **Recommendation:** v0.4 uses hook, v0.6 explore Claude Code plugin API for native notifications

5. **Cross-Repo Subscriptions:** Allow subscribing to branches in other repos?
   - **Recommendation:** v0.4 single-repo only, v0.6 add cross-repo support

---

## Success Criteria

### v0.4 is successful when:

1. ✅ Merge detector reliably detects branches merged to main
2. ✅ Notifications appear in Claude sessions via heartbeat hook
3. ✅ >85% test coverage on all new modules
4. ✅ Zero breaking changes to v0.3 functionality
5. ✅ Documentation complete and accurate
6. ✅ Manual testing validates end-to-end workflow
7. ✅ Performance overhead <5% of session runtime

---

## References

- [ROADMAP.md v0.4 section](/home/frankbria/projects/parallel-cc/ROADMAP.md#v04---branch-merge-detection--rebase-assistance)
- [v0.3 Implementation Plan](/home/frankbria/projects/parallel-cc/docs/v0.3-implementation-plan.md)
- [MCP SDK Documentation](https://github.com/modelcontextprotocol/sdk)
- [Git merge-base Documentation](https://git-scm.com/docs/git-merge-base)

---

**Document Version:** 1.0
**Created:** 2025-12-01
**Author:** Claude Code (System Architect)
**Status:** Ready for Implementation

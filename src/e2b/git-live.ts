/**
 * Git Live Mode - Push results to remote and create PR
 *
 * This module handles pushing E2B sandbox execution results directly
 * to a remote feature branch and creating a pull request, bypassing
 * the default download workflow.
 */

import type { Sandbox } from 'e2b';
import type { Logger } from '../logger.js';

/**
 * Options for git live push and PR creation
 */
export interface GitLiveOptions {
  repoPath: string;
  targetBranch: string;
  featureBranch?: string;
  prompt: string;
  executionTime: number;
  sessionId: string;
  sandboxId: string;
  githubToken: string;
}

/**
 * Result of git live operation
 */
export interface GitLiveResult {
  success: boolean;
  branchName: string;
  prUrl?: string;
  targetBranch: string;
  error?: string;
}

/**
 * Validate branch name to prevent shell injection
 *
 * Git branch names should only contain: a-z, A-Z, 0-9, -, /, _, .
 * This prevents shell metacharacters from being interpreted
 *
 * @param branchName - Branch name to validate
 * @returns true if valid, false otherwise
 */
export function isValidBranchName(branchName: string): boolean {
  // Allow only alphanumeric, hyphen, slash, underscore, and dot
  // Reject if contains spaces or is empty
  const validPattern = /^[a-zA-Z0-9/_.-]+$/;
  const trimmed = branchName.trim();

  // Reject if empty, has leading/trailing spaces, or contains invalid characters
  return (
    trimmed.length > 0 &&
    branchName === trimmed &&
    validPattern.test(trimmed)
  );
}

/**
 * Validate target branch name with strict requirements
 *
 * Target branches are typically known branches (main, develop, etc.)
 * so we validate strictly and reject invalid values rather than sanitizing
 *
 * @param targetBranch - Target branch name to validate
 * @throws Error if target branch contains invalid characters
 */
export function validateTargetBranch(targetBranch: string): void {
  if (!isValidBranchName(targetBranch)) {
    throw new Error(
      `Invalid target branch name "${targetBranch}". ` +
      `Branch names must contain only letters, numbers, hyphen, slash, underscore, and dot. ` +
      `Avoid shell metacharacters like: ; | & $ ( ) \` < > space`
    );
  }
}

/**
 * Sanitize branch name by removing invalid characters
 * Falls back to generated name if sanitization results in empty string
 *
 * @param branchName - Branch name to sanitize
 * @param fallbackPrompt - Prompt to use for fallback generation
 * @returns Sanitized safe branch name
 */
export function sanitizeBranchName(branchName: string, fallbackPrompt: string): string {
  // Remove any characters that aren't alphanumeric, hyphen, slash, or underscore
  const sanitized = branchName.replace(/[^a-zA-Z0-9/_-]/g, '').trim();

  // If sanitization results in empty string, fall back to generated name
  if (sanitized.length === 0) {
    return generateBranchName(fallbackPrompt);
  }

  return sanitized;
}

/**
 * Generate feature branch name from prompt
 *
 * @param prompt - User's execution prompt
 * @returns Slugified branch name with timestamp
 */
export function generateBranchName(prompt: string): string {
  // Slugify: lowercase, replace non-alphanumeric with hyphens
  const slug = prompt
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit to 50 chars

  // Add timestamp for uniqueness
  const timestamp = Date.now();
  return `e2b/${slug}-${timestamp}`;
}

/**
 * Generate PR body with execution details
 *
 * @param options - Git live options
 * @returns Formatted PR description
 */
export function generatePRBody(options: GitLiveOptions): string {
  const executionTimeFormatted = (options.executionTime / 1000).toFixed(1);

  return `# E2B Autonomous Execution

**Prompt:** ${options.prompt}

**Execution Details:**
- Execution Time: ${executionTimeFormatted}s
- Session ID: ${options.sessionId}
- Sandbox ID: ${options.sandboxId}
- Target Branch: ${options.targetBranch}

## Changes Summary

This PR contains the results of an autonomous E2B sandbox execution. The changes were generated automatically by Claude Code running in an isolated sandbox environment.

## Review Checklist

- [ ] Review all changed files
- [ ] Run tests locally
- [ ] Verify no sensitive data was committed
- [ ] Check for any unintended changes
- [ ] Validate the implementation meets requirements

<details>
<summary>E2B Execution Log</summary>

This PR was created automatically by \`parallel-cc sandbox-run --git-live\`.

**Session Information:**
- Session ID: \`${options.sessionId}\`
- Sandbox ID: \`${options.sandboxId}\`
- Execution completed in ${executionTimeFormatted} seconds

</details>

---

*Generated by [parallel-cc](https://github.com/frankbria/parallel-cc) E2B Sandbox Integration*`;
}

/**
 * Push results to remote feature branch and create pull request
 *
 * @param sandbox - E2B sandbox instance
 * @param logger - Logger instance
 * @param options - Git live options
 * @returns Result with branch name and PR URL
 */
export async function pushToRemoteAndCreatePR(
  sandbox: Sandbox,
  logger: Logger,
  options: GitLiveOptions
): Promise<GitLiveResult> {
  try {
    logger.info('Starting git live push and PR creation');

    // 1. Validate target branch to prevent shell injection
    validateTargetBranch(options.targetBranch);

    // 2. Generate branch name if not provided
    let branchName = options.featureBranch || generateBranchName(options.prompt);

    // 3. Sanitize branch name to prevent shell injection
    if (options.featureBranch) {
      // If user provided a custom branch name, validate and sanitize it
      if (!isValidBranchName(branchName)) {
        logger.warn(`Invalid branch name "${branchName}" contains unsafe characters. Sanitizing...`);
        branchName = sanitizeBranchName(branchName, options.prompt);
        logger.info(`Sanitized to: ${branchName}`);
      }
    }
    logger.info(`Using branch name: ${branchName}`);

    // 4. Create and checkout feature branch
    logger.info('Creating feature branch in sandbox');
    const checkoutResult = await sandbox.commands.run(`git checkout -b ${branchName}`, {
      cwd: '/workspace',
      timeoutMs: 10000
    });

    if (checkoutResult.exitCode !== 0) {
      throw new Error(`Failed to create branch: exit code ${checkoutResult.exitCode}`);
    }

    // 5. Stage all changes
    logger.info('Staging changes');
    const addResult = await sandbox.commands.run('git add .', {
      cwd: '/workspace',
      timeoutMs: 30000
    });

    if (addResult.exitCode !== 0) {
      throw new Error(`Failed to stage changes: exit code ${addResult.exitCode}`);
    }

    // 6. Commit with descriptive message
    logger.info('Creating commit');
    const commitMessage = `E2B execution: ${options.prompt}

Autonomous execution completed in ${(options.executionTime / 1000).toFixed(1)}s

Session: ${options.sessionId}
Sandbox: ${options.sandboxId}`;

    // Use temporary file to avoid shell injection in commit message
    const tempCommitFile = `/workspace/.git-commit-msg-${Date.now()}.tmp`;

    try {
      // Write commit message to temporary file using printf for safety
      // Base64 encode the message to avoid any shell interpretation
      const messageBase64 = Buffer.from(commitMessage, 'utf-8').toString('base64');
      const writeResult = await sandbox.commands.run(
        `printf '%s' "${messageBase64}" | base64 -d > "${tempCommitFile}"`,
        {
          cwd: '/workspace',
          timeoutMs: 5000
        }
      );

      if (writeResult.exitCode !== 0) {
        throw new Error(`Failed to write commit message file: exit code ${writeResult.exitCode}`);
      }

      // Commit using the file
      const commitResult = await sandbox.commands.run(`git commit -F "${tempCommitFile}"`, {
        cwd: '/workspace',
        timeoutMs: 10000
      });

      if (commitResult.exitCode !== 0) {
        throw new Error(`Failed to commit: exit code ${commitResult.exitCode}`);
      }
    } finally {
      // Clean up temporary file
      await sandbox.commands.run(`rm -f "${tempCommitFile}"`, {
        cwd: '/workspace',
        timeoutMs: 5000
      }).catch(() => {
        // Log but don't fail on cleanup errors
        logger.warn(`Failed to clean up temporary commit message file: ${tempCommitFile}`);
      });
    }

    // 7. Push to remote
    logger.info('Pushing to remote');
    const pushResult = await sandbox.commands.run(`git push -u origin ${branchName}`, {
      cwd: '/workspace',
      timeoutMs: 60000
    });

    if (pushResult.exitCode !== 0) {
      throw new Error(`Failed to push to remote: exit code ${pushResult.exitCode}`);
    }

    // 8. Create PR using gh CLI
    logger.info('Creating pull request');
    const prTitle = `E2B: ${options.prompt}`;
    const prBody = generatePRBody(options);

    // Escape single quotes for shell
    const escapedTitle = prTitle.replace(/'/g, "'\\''");
    const escapedBody = prBody.replace(/'/g, "'\\''");

    const ghResult = await sandbox.commands.run(
      `GITHUB_TOKEN=${options.githubToken} gh pr create --title '${escapedTitle}' --body '${escapedBody}' --base ${options.targetBranch}`,
      {
        cwd: '/workspace',
        timeoutMs: 30000
      }
    );

    if (ghResult.exitCode !== 0) {
      throw new Error(`Failed to create PR: exit code ${ghResult.exitCode}`);
    }

    // 9. Parse PR URL from output
    // gh pr create outputs the PR URL as the last line
    const prUrl = ghResult.stdout?.trim().split('\n').pop() || undefined;

    logger.info(`PR created successfully: ${prUrl}`);

    return {
      success: true,
      branchName,
      prUrl,
      targetBranch: options.targetBranch
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    logger.error(`Git live failed: ${errorMsg}`);

    return {
      success: false,
      branchName: options.featureBranch || 'unknown',
      targetBranch: options.targetBranch,
      error: errorMsg
    };
  }
}
